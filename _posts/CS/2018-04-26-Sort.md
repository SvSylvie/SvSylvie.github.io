---
layout: bread
title: Personal Summary About Algorithm
category: CS
header: Sort Algorithm
name: 排序比较与分析
isArticle: true
comments: true
tag: AD
---

<!-- TOC -->

- [排序算法](#排序算法)
    - [内部排序的算法主要思想](#内部排序的算法主要思想)
        - [选择](#选择)
            - [直接选择](#直接选择)
            - [堆排序](#堆排序)
        - [插入](#插入)
            - [直接插入](#直接插入)
            - [二分插入](#二分插入)
            - [希尔排序](#希尔排序)
        - [交换](#交换)
            - [冒泡](#冒泡)
            - [快排](#快排)
        - [归并](#归并)
        - [桶](#桶)
            - [基数排序](#基数排序)
            - [计数排序](#计数排序)
    - [稳定性分析](#稳定性分析)

<!-- /TOC -->

# 排序算法

![排序](/SvSylvie.github.io/blog-images/sort.jpg)

## 内部排序的算法主要思想
### 选择
#### 直接选择
    当前范围内寻找最小的放到第一个位置
    范围不断缩小
    最后剩一个元素止
    时间复杂度 
    空间复杂度  
    
#### 堆排序
    建堆
    左子节点索引2*i+1
    找到子节点较大的，如果大于父节点那么交换，从最后一个子节点的父节点向前，就能找到最大值放顶端，与最后元素交换，
    下一次范围减一
    每次找到当前范围最大的，直到剩两个or一个？

### 插入
#### 直接插入
    从第二个元素开始，找到前面比他大的后移
    所以前面的都是排好的

#### 二分插入
    i:0-len,a[i]插入到前面排好的范围，
    前面的范围从left(0)—right(i-1)开始不断缩小，直到left>right
    直接跟mid比，mid=(left+right)/2
    最终
    如果前面的值都小于a[i],即left一直后移
    left,right,mid都是(a[i-1])mid的值小于temp(a[i])
    left=i(temp还放在这里)
    如果前面有大于a[i]的，right左移直到找到最前面比他大的（left>right，mid=right,temp>a[mid]）（left=right+1)即left 的位置放temp，
    left 之后到i-1均后移一位

#### 希尔排序
    组相联
    相距d的为一组，组内直接插入排序
    d=math.floor(d/2),初值为len/2,
    最后一次排序即所有元素都在一组，d=1

### 交换
#### 冒泡
    从前往后或从后往前两两比较相邻元素，若为逆序则交换
    一趟将最大或最小放到最边上的位置，下一趟中前一趟确定的元素将不再参与
    
    

#### 快排
    找一个基准，一趟排序确定两个空间，一个全比基准值小，另一个全比基准值大，接着递归两个区间知道为空或长度为一
    实现：开辟两个数组一个存放left一个存放 right 
    注意传回上一级的left，right 中的值不能越来越少（left = quickSort（left））

### 归并
    归：不断向下分组，直到组长度为1，
    并：两组间最小的数相比，小的拿出放入最终的数组
    
### 桶
#### 基数排序
    找到最大数的位数确定排序的趟数
    注意取整
    二维数组实现队列
    第一趟将所有个位相同的放入一桶，桶从0到就，有元素就放桶，没元素就不放桶
    每个桶中的元素按顺序弹出（shift）放入a
    第二趟（a是排过的），再排十位

#### 计数排序

## 稳定性分析
>稳定性的意义:   
1、对于只是简单的数字排序，无意义  
2、排序的内容是一个复杂对象的多个数字属性，且其原本初始顺序存在意义，我们要保证稳定性（比如在价格降序的基础上进行销量的排序

>算法的稳定性{  
    不稳定：堆、快、希尔、直选  
    稳定： 基、冒、直插、二插、归  
}  

>快速记忆  
冒泡，选择，直接插入需要两个for循环，一遍找元素，一遍找位置  
快速、希尔，归并，堆，基于二分思想 nlog2n  
基数O(N*M),N为数据个数，M为数据位数  
计数排序，非比较，牺牲空间节省时间  


